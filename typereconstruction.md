# 型の再構築 (型推論)

**型の再構築** (type reconstruction) あるいは**型推論** (type inference) とは何か。その定義は相当曖昧である。

## 式の型推論

俗に C や (古い) C++ は型推論の無い言語だといはれるが、C でも全ての式に型注釈が必要となるわけではない。
例へば `1` と書けばそれは `int` 型のリテラルであり、`free` と書けばそれは引数も戻り値もない関数へのポインタである。
もし `1 + free()` と書けば `void` 型の式に加算演算子を適用できないといふエラーになる。
ここで `1` とか `1 + free()` とかの式の中に型注釈は一切現れてゐないが、それでも型検査は完遂される。
すなはち、C においても与へられた式の型を型注釈無しで「推論」することは可能である。

## 識別子の型推論

C が OCaml や Haskell などのいはゆる型推論のある言語と最も異なる点は、全ての識別子の宣言に型注釈が必要とされる点である。
識別子の宣言が束縛と同時に行はれる場合であっても、代入される式の (推論された) 型は識別子の型を決めるためには考慮されない。
OCaml や Haskell では、識別子の型は代入される式の型から自動的に決められる。
```c
/* C */
int i = 0;
```
```ocaml
(* OCaml *)
let i = 0
```

C から派生した言語でも、上記の様な束縛を伴ふ宣言での型注釈の省略が可能となってゐるものがある。例へば C# 3.0 や C++11 である。
```c++
/* C++11 */
auto i = 0;
```

特に C++11 でクロージャに変数を束縛するには、この種の型推論が必須である。なぜなら、クロージャの型は処理系が定義する特殊な型であり、プログラム内に明示することはできないからである。
```c++
/* C++11 */
auto f = [](int i) { return i * 2; };
```

## 引数の型推論

上記の議論では、識別子の宣言において束縛によって型注釈を代替することができるといふことを示した。
しかし関数の引数に対してはより高度な型推論が必要となる。関数の引数の宣言には束縛を伴ふことができないためである。
よって関数の引数の型は、型注釈に依らないで決めるとすれば、引数の関数内での使はれ方によって決めることになる。

TBD

## クラスの推論

TBD

