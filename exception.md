# 例外

## 例外の必要性

零による除算、オーバーフロー、配列の範囲外アクセスなどの例外的状況は、TAPL 3 章に定義される**行き詰まり** (stuck, 正規形だが値でない) の状態であるが、しかしこの様な状態が発生しないことを型システムによって保証することはいささか困難である。例へば零による除算を型システムによって防ぐには、除数が零でないことを保証するために「0 を含まない整数の型」を表す通常の整数とは異なる代数的データ型あるいは依存型を定義する必要があらう。さうすると型システム (と項の記述法) が複雑になって言語は実用的ではなくなってしまふ。
この様な状況が実行時に発生しないようにプログラマーが気を付けてプログラムし、必要に応じて帰納的試験手法でプログラムを検証するのが現実的である。ただし、型システムの健全性を保つために、処理系はこの様な例外的状況の発生を検出してプログラムの実行を安全に中断する仕組みの提供を求められる。(この様な例外は Java では `RuntimeException` のサブクラスに分類される)

また、メモリの使ひ果たしや実行時リンクエラーなどの障害もプログラム実行時に起こり得るが、これらはプログラム自身が障害から回復することが困難なものである。この様な状況では、単にプログラムの実行を中止するしか選択肢はない。(この様な例外は Java では `Error` のサブクラスに分類される)

この様な場面で、(型付けされた) 項の評価が完了する前に評価を中断する仕組みを**例外** (exception) といふ。

例外の別の使ひ途は、プログラムが回復すべきエラーを値とは異なる方法で通知することである。(検査例外の節にて後述)
また、例外に持たせるデータの型をうまく定義することで、関数が通常の戻り値とは異なる型の値を例外を通じて返すことができる。

OCaml では、大域脱出のために例外を使ふこともある。すなはち、C の `goto` に相当する使ひ方である。これは
OCaml の例外の実装が十分に高速であることによる。

## 例外の定義

ラムダ計算ベースの言語においては、TAPL 14 章にある様に、項の一種として例外を追加し
併せて評価規則も拡張することになる。
例外を値の一種としてしまふと、簡約基において引数が例外に評価された場合にも β 簡約を許してしまふ。値呼び[評価戦略](evaluation.md)においてはこれは好ましくないので例外は値の一種とはしない方が良い。ただし「型付けされた全ての正規形は値である」といふ性質は失はれる。
また、例外は任意の型を持てるので型の一意性も失はれる。

別のやり方としては、例外が発生したかどうかをバリアントで表す様に置き換へる方法もある。

## 例外からの回復

遅延[評価戦略](evaluation.md)では、ある項がいつ評価されるのかを知ることは一般に難しい。
特に、Haskell の様な必要呼び評価戦略 (値が必要になった時に必要なだけ項が評価される) では、ほとんど予測が不可能である。
この様な状況では、「この部分の項を評価する際に例外が発生した場合はこの例外ハンドラを使って回復する」といふ様な形式で例外の回復方法をプログラムすることは難しい。
実際 Haskell では、項が例外 `undefined` に評価された場合には処理系は直ちに停止する。`undefined` から回復する手段は提供されてゐない。

値呼び評価戦略では、項の評価タイミングはおほよそ予測可能である。特に、簡約基が β 簡約される前に必ずの両辺 (関数と引数) が評価されるため、項の構文的構造に基づいて「この項の評価中 (部分項の評価を含む) に例外が発生した場合にはこの例外ハンドラで回復する」といふ形式の回復が可能である。

Haskell では、IO モナドを使って値呼びを模倣することができる。そこでは (`undefined` とは異なる) 回復可能な例外を扱ふ手段も用意されてゐる。

## デストラクターと finally 文

一般的な手続型言語の例外処理では、例外が発生させられた時に対応する例外ハンドラが見付かるまで**スタックの巻き戻し** (stack unwinding) が行はれる。

C++ では、スタックの巻き戻し中に消滅するスタック上のオブジェクトのデストラクターが実行される。 
Java や C# など他の言語では finally 文(に相当する言語機能)によって巻き戻し中の「後片付け」が行へる。

スタックの巻き戻し中に実行されるデストラクターや finally 文の主な意義は、回収すべき資源を適切に回収することである。
ただし、資源の回収漏れの影響がプログラム外に及ばずかつ例外が回復されないのであれば、スタックの巻き戻しをそもそも行はずにただちにプログラムを終了させても良い。
逆に資源の回収がプログラム外に影響する場合 (例へば、一時ファイルが削除されるなど)、たとへ例外が回復されずプログラムがいづれ終了するとしてもデストラクター・finally 文を実行することは重要である。

### 第二の例外

スタックの巻き戻し中に実行するデストラクターや finally 文で問題となるのは、デストラクターの実行中に別の例外が発生し(それが回復されなかっ)た場合にどうするのかといふことである。C++ ではこの場合巻き戻しは中止され `std::terminate` 関数によって処理系が停止する。

他の言語では新たな例外は finally 文の外に波及するのが一般的である。その場合、元の例外は失はれる。
ただし、新たな例外に元の例外の情報を持たせることによって例外ハンドラが元の例外の情報を知ることができる様にすることはできる。

新たな例外をどの様に扱ふかについてのもう一つの解は、両方の例外をリストか何かに入れて覚えておいて、例外ハンドラでそれを受け取るといふやり方である。
この方法の問題は、発生した二つの例外の種類と例外ハンドラが受け取ることのできる例外の種類をどの様に関連付ければよいのかが明らかでないことである。

## 例外の分類 (タグ付け)

例外を分類し、特定の例外ハンドラが特定の種類の例外にのみ反応する様にプログラミングできると便利である。

例外の単純な分類法は、C の `errno` の様に例外の種類に定数値を割り振る方法である。
しかしこの方法は種類に応じて異なる型の付加情報を例外に持たせるには都合が悪い。

OCaml のやうに例外をバリアントとして分類すると種類に応じて異なる型の情報を持たせられる。また、例外ハンドラが例外に反応するかどうかはパターンマッチングによって選別できる。

C++ や Java では、実行時キャストが成功するかどうかで例外ハンドラを実行するかどうかを決める。すなはち、例外はクラスの派生関係(の推移閉包)がなす半順序によって分類される。
これの便利なところは、例外ハンドラが反応すべき例外の種類の抽象化が可能になる点である。例へば Java では、`FileNotFoundException` と `MalformedURLException` はどちらも `IOException` の子クラスである。ファイルが見つからない場合と URL が不正な場合とに対して異なる様に対応したければ、二つの種類の例外に対してそれぞれ `catch` 節を書けばよい。それらも含めた入出力に関する全ての例外に対して同じ様に対応したければ、ただ `IOException` について `catch` 節を書けばよい。

以下の様に、派生関係による分類をバリアントで模倣することはできる。ただしより派生されたクラスほど記述が煩雑になるので簡潔にするための言語によるサポートが望まれる。

``` ocaml
# type io_exception = FileNotFoundException | MalformedURLException;;
type io_exception = FileNotFoundException | MalformedURLException
# exception IOException of io_exception;;
exception IOException of io_exception
# try raise (IOException FileNotFoundException) with
  | IOException MalformedURLException -> 0
  | IOException _ -> 1;;
- : int = 1
```

## 検査例外

Java の型システムでは、`RuntimeException` にも `Error` にも属しない例外は**検査例外** (checked exception) であり、例外が発生する可能性とその例外に対応する例外ハンドラの存在が処理系によって照合される。
検査例外が発生する可能性があるにもかかはらず対応する例外ハンドラが無い場合、型エラーとなる。

型システムとしては、通常の型付きラムダ計算を検査例外に対して拡張すると、項は型に加へて発生しうる例外の種類の集合を持つ様になる: `Γ ⊢ t : T | E1, E2, ...`
また関数の型も、引数と戻り値の型に加へて、関数が投げうる例外の種類の集合を持つ様になる。

検査例外の特長は、実行時に起こり得るエラーであってプログラムが適切に回復すべきものについて、例外ハンドラを書くことをプログラマーに忘れさせないことである。

Java の検査例外の不便なところの一つは、関数が投げうる例外の種類を示す型注釈がしばしば繁雑になるといふ点である。

しかしより根本的な問題として、関数に対して要求される型注釈はジェネリクス (パラメータ型多相) と極めて相性が悪いことが挙げられる。
抽象的に任意の関数を表すために
[`Function`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)
といふインターフェースが用意されてゐる。しかし Java には C++11 のパラメータパックの様な物はないため、関数が任意の個数の検査例外を投げうる様にインターフェースを宣言することができない。
結果として、`Function` インターフェースを実装する関数は検査例外を一切投げることができない。
(仮に Java がパラメータパックに対応したとしても、型注釈が繁雑になる問題は残る。)

## 例外の実装

