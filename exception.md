# 例外

## 例外の必要性

## 例外の定義

ラムダ計算ベースの言語においては、TAPL 14 章にある様に、項の一種として例外を追加し
併せて評価規則も拡張することになる。
例外を値の一種としてしまふと、簡約基において引数が例外に評価された場合にも β 簡約を許してしまふ。値呼び[評価戦略](evaluation.md)においてはこれは好ましくないので例外は値の一種とはしない方が良い。ただし「型付けされた全ての正規形は値である」といふ性質は失はれる。

別のやり方としては、例外が発生したかどうかをバリアントで表す様に置き換へる方法もある。

## 例外からの回復

遅延[評価戦略](evaluation.md)では、ある項がいつ評価されるのかを知ることは一般に難しい。
特に、Haskell の様な必要呼び評価戦略 (値が必要になった時に必要なだけ項が評価される) では、ほとんど予測が不可能である。
この様な状況では、「この部分の項を評価する際に例外が発生した場合はこの例外ハンドラを使って回復する」といふ様な形式で例外の回復方法をプログラムすることは難しい。
実際 Haskell では、項が例外 `undefined` に評価された場合には処理系は直ちに停止する。`undefined` から回復する手段は提供されてゐない。

値呼び評価戦略では、項の評価タイミングはおほよそ予測可能である。特に、簡約基が β 簡約される前に必ずの両辺 (関数と引数) が評価されるため、項の構文的構造に基づいて「この項の評価中 (部分項の評価を含む) に例外が発生した場合にはこの例外ハンドラで回復する」といふ形式の回復が可能である。

Haskell では、IO モナドを使って値呼びを模倣することができる。そこでは (`undefined` とは異なる) 回復可能な例外を扱ふ手段も用意されてゐる。

## デストラクターと finally 文

一般的な手続型言語の例外処理では、例外が発生させられた時に対応する例外ハンドラが見付かるまで**スタックの巻き戻し** (stack unwinding) が行はれる。

C++ では、スタックの巻き戻し中に消滅するスタック上のオブジェクトのデストラクターが実行される。 
Java や C# など他の言語では finally 文(に相当する言語機能)によって巻き戻し中の「後片付け」が行へる。

スタックの巻き戻し中に実行されるデストラクターや finally 文の主な意義は、回収すべき資源を適切に回収することである。
ただし、資源の回収漏れの影響がプログラム外に及ばずかつ例外が回復されないのであれば、スタックの巻き戻しをそもそも行はずにただちにプログラムを終了させても良い。
逆に資源の回収がプログラム外に影響する場合 (例へば、一時ファイルが削除されるなど)、たとへ例外が回復されずプログラムがいづれ終了するとしてもデストラクター・finally 文を実行することは重要である。

### 第二の例外

スタックの巻き戻し中に実行するデストラクターや finally 文で問題となるのは、デストラクターの実行中に別の例外が発生し(それが回復されなかっ)た場合にどうするのかといふことである。C++ ではこの場合巻き戻しは中止され `std::terminate` 関数によって処理系が停止する。

他の言語では新たな例外は finally 文の外に波及するのが一般的である。その場合、元の例外は失はれる。
ただし、新たな例外に元の例外の情報を持たせることによって例外ハンドラが元の例外の情報を知ることができる様にすることはできる。

新たな例外をどの様に扱ふかについてのもう一つの解は、両方の例外をリストか何かに入れて覚えておいて、例外ハンドラでそれを受け取るといふやり方である。
この方法の問題は、発生した二つの例外の種類と例外ハンドラが受け取ることのできる例外の種類をどの様に関連付ければよいのかが明らかでないことである。

## 検査例外

## 例外の実装

