# 多相性 (多態性)

一つの項が複数の異なる型を持つとき、その項は**多相的** (polymorphic) である。

一つの項が異なる型を持ってゐるので、それらの型を纏めて交差型で表すこともできる。とはいへ、多相性を表すために交差型を用ゐるのはほとんどの場合 項の持つ型や処理系の設計を複雑にするだけである。

## アドホックな多相性

異なる型の異なる値が同じ識別子を共有するとき、それは**オーバーロード** (overload) されてゐるといふ。これをアドホックな多相性 (ad-hoc polymorphism) といふ。ここで多相的なのは値ではなく識別子である。

オーバーロードされた識別子が使用されるときどの値が使用されるかはコンパイル時に決定されるのが一般的である。オーバーロードされた識別子単体では値の選択はできないので、識別子を使用する際は型注釈や型の分かってゐる引数の適用を伴ふ必要がある。

オーバーロードを実行時に解決しようとするならば、実行時型情報を用いて動的に値を選択することになる。これを**動的ディスパッチ** (dynamic dispatch) といふ。
型の違ひによる動作の変化を実行時型情報に適切に抽象化しそれを引数として渡すことで、単相的な関数が多相的な関数として振る舞へるやうになる。これを**内包的多相** (intensional polymorphism) といふ。

## 仮想関数

オブジェクト指向プログラミングで、[オーバーライド](overriding.md)によって動的ディスパッチされるメソッドを**仮想関数** (virtual function) といふ。

## パラメーターによる多相

パラメーターによる多相 (parametric polymorphism) は、項の型による抽象化である。関数を型に適用することで、その型に応じた型を持つ項が得られる。

例へば `nil` に型を渡すとその型を要素型とする空リストが得られる:

```
List :: * → *
nil : ΠT::*. List T
nil Nat : List Nat
nil (List Nat) : List (List Nat)
```

`Π` の代はりに `∀` を使ふ流儀もある。

### 型適用の構文解析

関数に項のみならず型までも適用できるやうになると、関数適用の構文解析をする際に引数を正しく型として処理系が認識する必要が出て来る。言語設計上いくつかの方法がある。

一つ目の方法は、項と型を別の構文として扱ふもの。この方法では、例へば型を `[ ]` で囲むなどして項と型の区別を構文上明らかにすることになる。

二つ目の方法は、項と型の構文を統一し区別せずに構文解析し、型検査時に引数が型か項か判断するもの。この方法では、項と型を区別するための記号等は不要になるが、型を項と互換性のある構文で記述しなければならなくなる。

三つ目の方法は、引数として渡す型をコード上に明示させずに、常に処理系に推論させるもの。この方法では型を記述するための構文の拡張がそもそも不要となる。

``` ocaml
(* 例へば OCaml では、空リストの型は ΠA::*. List A となる *)
# let nil = [];;
val nil : 'a list = []
(* また Cons の型は ΠA::*. A → List A → List A である *)
# let cons h t = h::t;;
val cons : 'a -> 'a list -> 'a list = <fun>
(* cons をユニットに適用するとき、引数 h の型がユニット型であることから
   型引数 A がユニット型であると推論される *)
# cons ();;
- : unit list -> unit list = <fun>
(* cons の引数を入れ替へて見ると、型は ΠA::*. List A → A → List A *)
# let cons' t h = h::t;;
val cons' : 'a list -> 'a -> 'a list = <fun>
(* これを nil に適用すると、型は ΠA::*. A → List A *)
# cons' nil;;
- : '_a -> '_a list = <fun>
(* 型引数を明示すると λA::*. cons' A (nil A) *)
```

## 部分型多相

[部分型](subtyping.md)によって型が項を抽象化するレベルを変へることができる。オブジェクト指向プログラミングでは部分型多相を単に多相性と呼ぶことが多い。
