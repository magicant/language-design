# 依存型

**依存型** (dependent type) とは項による型の抽象化である。
例へば「長さ `n` のリスト」を `List n` で表すとすれば、`List` の種は `Nat → *`。

C99 の配列型や C++ のテンプレートはある種の依存型と言へる。

型検査時に型の同一性を判定する必要がある以上、依存型の引数となる項はコンパイル時に比較可能でなければならない。しかし例へば `List (n+1)` と `List (1+n+0)` が同一の型であることを知るには自然数の加算の零元や交換法則を型検査時に取扱はなければならない。一般にそれは相当に困難な作業であるから、実用的な言語では依存型の応用範囲はもっと限定される。
例へば C++ のテンプレートでは、依存型の引数はコンパイル時定数であることが求められる。引数の型も整数型やポインタ型などに制限される。

## 依存積型

関数の引数の型が別の引数に依存する場合にその型を正しく種付けできる様にするためにより一般化された型の書き方が必要となる。
例へば長さ `n : Nat` を受け取ってその長さのリストを作って返す関数の型は `Πn:Nat. List n` となる。これを `(n:Nat) → List n` と書く流儀もある。
一般に`A → B` は `Π_:A. B` の糖衣構文となる。

依存積を `Π` で書くのは、関数がある種の直積型とみなされるためである。関数が取り得るあらゆる引数の値のそれぞれに対して、関数がその引数の値を写す先の値が存在する。`Π` はそれらを全て並べてできる直積の型を表してゐる。関数に引数を与へて戻り値を得ることは、直積から一つの要素を選び出すのに等しい。

## C99 の配列型

二次元配列引数のサイズを別の引数で指定する例:

``` c
void zeroize(size_t n, int array[n][n]) {
  for (size_t i = 0; i < n; ++i)
    for (size_t j = 0; j < n; ++j)
      array[i][j] = 0;
}
```

これをラムダ計算の型に直すと、二次元配列の型は `IntArray :: Nat → Nat → *` となり関数は `zeroize : Πn:Size. IntArray n n → Unit` となる。

## 依存和型

`Πx:A. B` がある以上 `Σx:A. B` だってある。これは要素の型に依存性がある直積型を表す。
上の `zeroize` 関数を逆カリー化すると型は `(Σn:Size. IntArray n n) → Unit` となる。直積の第二要素の型 `IntArray n n` が最初の要素の項 `n` に依存してゐる。
一般に `A * B` は `Σ_:A. B` の糖衣構文となる。

この様な直積が依存和と呼ばれるのは、それが実際には直和だからである。直積の一つ目の要素は直和における「タグ」であり、二つ目の要素はタグによって型が定まる直和の値である。

また一般に、依存和は依存積と全称型によって構成できる。

```
Σx:A. B ≡ ΠR. (Πx:A. B → R) → R
```

逆に依存積を依存和と全称型によって構成することもできる。(`Π` と `Σ` を入れ換へればよい。)
