# 依存型

項による型の抽象化。
例へば「長さ `n` のリスト」を `List n` で表すとすれば、`List` の種は `Nat → *`。

C99 の配列型や C++ のテンプレートはある種の依存型と言へる。

型検査時に型の同一性を判定する必要がある以上、依存型の引数となる項はコンパイル時に比較可能でなければならない。しかし例へば `List (n+1)` と `List (1+n+0)` が同一の型であることを知るには自然数の加算の零元や交換法則を型検査時に取扱はなければならない。一般にそれは相当に困難な作業であるから、実用的な言語では依存型の応用範囲はもっと限定される。
例へば C++ のテンプレートでは、依存型の引数はコンパイル時定数であることが求められる。引数の型も整数型やポインタ型などに制限される。

## 依存積型

関数の引数の型が別の引数に依存する場合にその型を正しく種付けできる様にするためにより一般化された型の書き方が必要となる。
例へば長さ `n : Nat` を受け取ってその長さのリストを作って返す関数の型は `Πn:Nat. List n` となる。これを `(n:Nat) → List n` と書く流儀もある。
一般に`A → B` は `Π_:A. B` の糖衣構文となる。

## C99 の配列型

二次元配列引数のサイズを別の引数で指定する例:

``` c
void zeroize(size_t n, int array[n][n]) {
  for (size_t i = 0; i < n; ++i)
    for (size_t j = 0; j < n; ++j)
      array[i][j] = 0;
}
```

これをラムダ計算の型に直すと、二次元配列の型は `IntArray :: Nat → Nat → *` となり関数は `zeroize : Πn:Size. IntArray n n → Unit` となる。

## 依存和型

`Πx:A. B` がある以上 `Σx:A. B` だってある。これは要素の型に依存性がある直積型を表す。
上の `zeroize` 関数を逆カリー化すると型は `(Σn:Size. IntArray n n) → Unit` となる。直積の第二要素の型 `IntArray n n` が最初の要素の項 `n` に依存してゐる。
一般に `A * B` は `Σ_:A. B` の糖衣構文となる。
