# 参照 (差し替へ可能なポインター)

TAPL 13 章にあるやうな単純な参照の定式化では、参照を扱へる言語の評価規則はストアと項との組の変化 `t1 | μ1 → t2 | μ2` として表される。
ストアは位置 (アドレス) から値への部分関数である。

## 参照透過性

参照透過性の決まりきった定義といふものは存在し無いやうである。ここでは妥当さうな定義を挙げる。

### 操作的意味論

上の、ストアによって拡張された評価規則の文脈では、ある項 `t` が以下の条件を満たすときそれは**参照透過性**を持つ:

- `t` の正規形はストアによらず一意である。(すなはち、評価はストアから影響を受けない。)
- `t | μ1 →* t2 | μ2` ならば `μ1` と `μ2` は等しい。(すなはち、評価はストアに影響を与へない。)

二つ目の条件はもっと弱くすることもできる。

- 条件を「`t | μ1 →* t2 | μ2` かつ `t2` が正規形ならば `μ1` と `μ2` は等しい」とすると、評価の途中で一時的にストアが変化することを認めるやうになる。ただし、これはマルチスレッドプログラムにおいては望ましくない性質だらう。
- 条件を「`t | μ1 →* t2 | μ2` ならば `μ2` は `μ1` の拡張である」とすると、評価の途中でストアに値が追加されることを認めるやうになる。(ここでいふ拡張とは、関数を順序対の集合として見た時に元の関数を部分集合として含む関数をいふ。) ただし、この条件と一つ目の一意性条件は相性が悪く、実行時に毎回異なる位置に値を確保するといふことができなくなってしまふ。条件をより厳密に定めるか、分離論理を使ふことで問題を緩和できる。

### 公理的意味論

分離論理では参照透過性は「命令の事前条件においてヒープが空であること」と定義できる。「事後条件でもヒープが空であること」といふ条件を加へることもできる。

### 評価戦略との関係

参照は遅延評価戦略や非決定的評価戦略と全く相性が悪い。
ただし、遅延評価の言語で参照が全く扱へないといふことではなく、Haskell の `STRef` のやうに抽象化された評価戦略の中では取扱ふことができる。

実際のところ、Haskell の `ST` モナドは分離論理の命令を抽象化したものと言へる。
`ST` モナドの最初の型パラメータは分離論理における命令の事前条件におほよそ対応する。型パラメータが具体化されてゐなければ、どんな事前条件でも命令が実行できるといふことなので、事前条件として空のヒープを指定してゐるのに等しい。

# 参照 (透過的なポインター)

C++ における参照は、本質的にはポインターと同じであるが、参照自身が参照されてゐるオブジェクトと透過的に等しく扱はれる点が異なる。従って、

- 参照への参照は存在しない
- ナル参照は存在しない
- 参照変数は宣言と同時に束縛されねばならない
- 参照変数が指してゐるオブジェクトを束縛し直すことはできない

意味論の観点では、参照は間接参照演算子の結果を正しく定義するために必要な概念である。
C とは異なり、C++ でオブジェクトをコピーすることは副作用を伴ふことがある。よって、間接参照演算子の結果はポインターが指してゐたオブジェクトのコピーではなくオブジェクトそのもの(と透過的に等しいもの)でなければならない。

ポインターに対する参照の最も実利的な点は、対象のオブジェクトにアクセスするためにいちいち間接参照演算子をポインターに噛ます必要がなくなること、およびナルにならないことである。
実際上は、参照はオブジェクトをコピーせずに同じオブジェクトを指す変数を作るための手段となる。
