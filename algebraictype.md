# 代数的データ型

代数的データ型は直積と直和と再帰によって構成される。

## 直積

既にある二つの値を纏めて一つの値として扱へる様にしたものが**直積** (direct product) である。集合論的には**デカルト積** (Cartesian product) に、圏論的には**積** (product) に相当する。
一般に、「積の積」や「積の積の積」を再び一つの値としてみなすことで、いくらでも多くの値を纏めることができる。

直積を言語内で使へるやうにするためのプリミティブとしては、直積を作るための構築関数が必要である。

```
Pair : * → * → *
Pair = λA. λB. ΠR. (A → B → R) → R
cons : ΠA. A → ΠB. B → Pair A B
cons = λA. λa. λB. λb. λR. λf. f a b
```

`Pair` の型定義が言語内で透過的でない場合は、直積から値を取り出すための射影関数も必要となる。

```
first : ΠA. ΠB. Pair A B → A
first = λA. λB. λp. p (λa. λb. a)
second : ΠA. ΠB. Pair A B → B
second = λA. λB. λp. p (λa. λb. b)
```

### レコード

任意の個数の値を纏めることができる様に一般化された直積について、それぞれの値を識別子で区別できる様にしたものを**レコード** (record) といふ。

## 直和

二つの型が与へられた時、そのどちらかの型の値を持ってゐる値が**直和** (direct sum) である。俗に**バリアント** (variant) とも言ふ。より正確には**非交和** (disjoint union または discriminated union) と言った方が良い。C で union を共用体と訳すのに倣って discriminated union を判別共用体と訳す流儀もある。
一般に、「和の和」や「和の和の和」を再び一つの値としてみなすことで、いくらでも多くの型を扱ふことができる。

直和を言語内で使へるやうにするためのプリミティブとしては、直和を作るための注入関数が必要である。

```
Either : * → * → *
Either = λA. λB. ΠR. (A → R) → (B → R) → R
inLeft : ΠA. A → ΠB. Either A B
inLeft = λA. λa. λB. λR. λf. λg. f a
inRight : ΠB. B → ΠA. Either A B
inRight = λB. λb. λA. λR. λf. λg. g a
```

`Either` の型定義が言語内で透過的でない場合は、直和から値を取り出すためのプリミティブも必要となる。これは OCaml の `match … with …` や Haskell の `case … of …` の様に専用の構文によって書かれることになる。

### タグ付き和

直和が持てる値の型を識別子で区別できる様にしたものを**タグ付き和** (tagged union) といふ。
直和をサポートする言語では普通、直和はタグ付き和として実装される。識別子無しでは型を番号 (添字) によってしか区別できず、プログラムが読み難くなるためである。それ故、タグ付き和を直和とかバリアントなどと呼ぶことも多い。

## 再帰型

TBD
