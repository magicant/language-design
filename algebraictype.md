# 代数的データ型

**代数的データ型** (algebraic data type) は直積と直和と再帰によって構成される型である。

## 直積

既にある二つの値を纏めて一つの値として扱へる様にしたものが**直積** (direct product) である。集合論的には**デカルト積** (Cartesian product) に、圏論的には**積** (product) に相当する。
一般に、「積の積」や「積の積の積」を再び一つの値としてみなすことで、いくらでも多くの値を纏めることができる。

直積を言語内で使へるやうにするためのプリミティブとしては、直積を作るための構築関数が必要である。

```
Pair : * → * → *
Pair = λA. λB. ΠR. (A → B → R) → R
cons : ΠA. A → ΠB. B → Pair A B
cons = λA. λa. λB. λb. λR. λf. f a b
```

`Pair` の型定義が言語内で透過的でない場合は、直積から値を取り出すための射影関数も必要となる。

```
first : ΠA. ΠB. Pair A B → A
first = λA. λB. λp. p (λa. λb. a)
second : ΠA. ΠB. Pair A B → B
second = λA. λB. λp. p (λa. λb. b)
```

### レコード

任意の個数の値を纏めることができる様に一般化された直積について、それぞれの値を識別子で区別できる様にしたものを**レコード** (record) といふ。

## 直和

二つの型が与へられた時、そのどちらかの型の値を持ってゐる値が**直和** (direct sum) である。俗に**バリアント** (variant) とも言ふ。より正確には**非交和** (disjoint union または discriminated union) と言った方が良い。C で union を共用体と訳すのに倣って discriminated union を判別共用体と訳す流儀もある。
一般に、「和の和」や「和の和の和」を再び一つの値としてみなすことで、いくらでも多くの型を扱ふことができる。

直和を言語内で使へるやうにするためのプリミティブとしては、直和を作るための注入関数が必要である。

```
Either : * → * → *
Either = λA. λB. ΠR. (A → R) → (B → R) → R
inLeft : ΠA. A → ΠB. Either A B
inLeft = λA. λa. λB. λR. λf. λg. f a
inRight : ΠB. B → ΠA. Either A B
inRight = λB. λb. λA. λR. λf. λg. g a
```

`Either` の型定義が言語内で透過的でない場合は、直和から値を取り出すためのプリミティブも必要となる。これは OCaml の `match … with …` や Haskell の `case … of …` の様に専用の構文によって書かれることになる。

### タグ付き和

直和が持てる値の型を識別子で区別できる様にしたものを**タグ付き和** (tagged union) といふ。
直和をサポートする言語では普通、直和はタグ付き和として実装される。識別子無しでは型を番号 (添字) によってしか区別できず、プログラムが読み難くなるためである。それ故、タグ付き和を直和とかバリアントなどと呼ぶことも多い。

使用できるタグの名前 (とそのタグに関連付ける値の型) を予め宣言させるタイプのものと、タグを即席で作ることのできるタイプのものとがある。
後者では、プログラム内の異なる箇所で作られた同じ識別子のタグが異なる型の値を持つ可能性があるが、その様なタグを同一箇所で混ぜて使ふことは禁じられる。

### 開かれた直和

通常のタグ付き和では、一つの直和の型の値が取れるタグの種類は有限個に制限され、それらは型付けにおいて全て特定される。
これに対し、取れるタグの種類を型付けにおいて(必ずしも全ては)特定しないタイプのものを開かれた直和と言ふ。

開かれた直和のパターンマッチングでは、取り得るタグの種類を具体名で網羅することはできないので、明示的にマッチングされないタグを全て処理できるワイルドカードパターンが必要となる。

開かれた直和の型は、「値が任意のタグを取れる」といふ点で本質的に一つしかない。ただしタグを即席で作れる場合は、タグに対する値の型の一意性を保証するためにタグの名前と型を直和の型に含めて管理する必要があり、名前と型の組み合はせごとに異なる型となる。

## 再帰型

TBD

## 代数的データ型の定義

言語内において直積・直和・再帰を独立して定義できる様にすることも可能であるが、一般的な関数型言語ではこれら(のうち特に直和と再帰)は合はせて一つの構文で宣言される。

例へば OCaml では、タグ付き和と再帰はどちらも「データ型の宣言」として纏めて一つの宣言構文で書かれる。

```ocaml
# 1, "abc";; (* 直積は即席で作れる *)
- : int * string = (1, "abc")
# type int_float_pair = { i : int; f : float; };; (* レコードは予め宣言が必要 *)
type int_float_pair = { i : int; f : float; }
# {i = 42; f = 0.};;
- : int_float_pair = {i = 42; f = 0.}
# type ('a, 'b) either = Left of 'a | Right of 'b;; (* 予め宣言が必要なタグ付き和 *)
type ('a, 'b) either = Left of 'a | Right of 'b
# Right 1;;
- : ('a, int) either = Right 1
# type int_list = Nil | Cons of int * int_list;; (* タグ付き和と直積と再帰の組み合はせ *)
type int_list = Nil | Cons of int * int_list
# Cons (1, Nil);;
- : int_list = Cons (1, Nil)
# `Int 0;; (* 即席でタグ付き和を作ることもできるが、再帰はできない *)
- : [> `Int of int ] = `Int 0
```

Haskell ではレコードの宣言もデータ型の宣言の中で行はれる。(レコードは直和のタグが取れる値としてのみ宣言できる)

```haskell
data IntList = Nil | Cons {head :: Int, tail :: IntList}
```

直和と再帰を独立して宣言できる架空の言語を考へてみる。

```
(* タグとして既述の cons の他に nil を定義しておく *)
Nil : *
nil : Nil

(* Nil と Pair を使って IntList を宣言する *)
IntList : *
IntList = μT. Nil | Pair Int T
```

リストを生成するための `cons` が `Pair` 型の値を生成するのは不自然に見える。`cons` の第二引数が IntList であることを、`cons` を宣言する段階で明示したい。しかしそのためには、`IntList` といふ型があることが `cons` を宣言する段階で分かってゐなければならない。`IntList` の種の宣言と内容の定義を分けて書くことで対処しようとすると、以下の様になる。

```
(* 先に IntList の種を宣言する *)
IntList : *

(* cons を定義する *)
Cons : *
cons : Int → IntList → Cons

(* IntList を定義する *)
IntList = Nil | Cons
```

結局、`cons` の定義と `IntList` の定義が相互に依存してゐるためにそれらを分けて書かうとするとややこしくなる。故に、直和と再帰を一つの構文内で纏めて宣言する方式を採用する言語が多い。

上の架空言語では再帰的な型を定義するために再帰演算子 μ を用ゐた。すなはち、再帰的な型を即席で作ることができる。この様な方式の型システムを**構造的** (structural) 型システムといふ。
一方 OCaml や Haskell など多くの言語では再帰演算子 μ はコード内に明示されず、代はりに再帰的な型には必ず名前が付けられる。型の定義の中でその名前を使用することで、自然に再帰を表現できる。この様な方式の型システムを**名前的** (nominal) 型システムといふ。名前的型システムの主な利点は、

- 再帰的な型 (特に、相互再帰する複数の型) をより直観的な書き方で宣言できる
- 実行時型情報を取り扱ひやすい
- 型の等価性や部分型関係の判定がより簡単になる

ただし構造的型システムにも以下の様な特長がある。

- 型の等価性や部分型関係をより厳密に判定できる
- 型システムの性質について理論的に検証しやすい
